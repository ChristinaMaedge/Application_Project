---
title: "Application Project Umsatzprognose Bäckerei"
author: "Christina M. Mädge, Marco Landt-Hayen"
date: "6.4.2020"
output: rmdformats::readthedown
---

```{r message=FALSE, error=FALSE, warning=FALSE}
library(tidyverse) # Datenaufbereitung und ggplot
library(lubridate) # Umgang mit Datum und Zeit
```

# 1. Allgemeine Projektinformationen

## 1.1 Ausgangslage
Die Bestellung von Bäckereien ist häufig noch ein manueller und zeitaufwändiger Prozess, der auf adjustierten Vorwochenwerten basiert. Eine systematische Planung unter Einbeziehung von Mustern findet nur eingeschränkt statt.

## 1.2 Zielsetzung 
Es wird ein Prognosemodell entworfen, das Bäckereien ein bessere Planungsgrundlage auf Warengruppenebene bietet. 
Lösungsansatz

Mit Hilfe von verschiedenen Daten und Einflussfaktoren soll diese Umsätze je Warengruppe prognostiziert werden. 
-	Umsatzdaten, Wetterdaten, Veranstaltungsdaten
-	Weitere Einflussfaktoren (Neueröffnung, Aktionen,…)

## 1.3 Datenbasis:
-	2012 bis Ende 2019
-	Umsätze je Warengruppe und Tag
-	(Retourenquoten)
-	(Zeitpunkt letzter Verkauf)
-	(Öffnungszeiten)


# 2 Datenexploration

## 2.1 Einlesen der Daten

Im ersten Schritt müssen die Daten zunächst eingelesen werden um sie bearbeiten zu können:
```{r}
# mit read_csv einlesen um eine Veränderung der Datentypen (bzw. eine Faktorisierung) zu verhindern!
Beispieldaten <- read_csv("data/Beispieldaten.csv")
KiWo <- read_csv("data/KiWo.csv")
Wetter <- read_csv("data/Wetter.csv")
```

## 2.2 Überprüfung der Datenstrukturen

* Datensatz **Beispieldaten**
```{r}
str(Beispieldaten)
glimpse(Beispieldaten)
typeof(Beispieldaten$Datum)
range(Beispieldaten$Warengruppe)
range(Beispieldaten$Umsatz)
```

Der Datensatz **Beispieldaten** ist ein Dataframe, enthält 11164 Zeilen und 3 Variablen:

* Datum (`date`)
* Warengruppe (`int`) mit den Warengruppen 1 - 6
* Umsatz (`dbl`) mit Werten zwischen 7.05 und 1879.46.

Umsätze werden jeweils 5 mit Nachkommastellen angezeigt. Hier sollte eine Änderung vorgenommen und die Variable auf zwei Nachkommastellen gerundet werden (?).

* Datensatz **KiWo**
```{r}
str(KiWo)
glimpse(KiWo)
any(KiWo$KielerWoche != 1)  # Prüfung: Ist die Ausprägung in irgendeiner Zelle der Spalte ungleich 1?
all(KiWo$KielerWoche == 1)  # Prüfung: Sind alle Ausprägungen gleich 1? 
```

Der Datensatz **KiWo** enthält 71 Zeilen und die beiden Variablen Datum (`date`) und KielerWoche (`int`), wobei die einzige Ausprägung der Variablen KielerWoche die Ziffer 1 ist.

```{r}
str(Wetter)
glimpse(Wetter)
range(Wetter$Bewoelkung, na.rm = TRUE)
range(Wetter$Temperatur, na.rm = TRUE)
range(Wetter$Windgeschwindigkeit)
range(Wetter$Wettercode, na.rm = TRUE)
```

Der Datensatz **Wetter** enthält 2601 Zeilen und fünf Variablen:

* Datum (`date`)
* Bewoelkung (`int`) mit Werte von 0 bis 8
* Temperatur (`dbl`) mit Werten zwischen -10.25 und 32.67 Grad Celsius
* Windgeschwindigkeit (`int`) mit Werten zwischen 3 und 35    ?????????? Einheit?
* Wettercode (`int`) mit Werten zwischen 0 und 95.

Alle Datensätze enthalten die Variable `Datum` über die die Datensätze vereinigt werden können. 

### 2.3 Überprüfung des Anfangs- und Endzeitpunkt der Datumsattribute in den Datensätzen
```{r}
min(Beispieldaten$Datum)
max(Beispieldaten$Datum)
range(KiWo$Datum)
range(Wetter$Datum)
```

* Die Daten des Datensatzes **Beispieldaten** reichen vom 01.07.2013 bis zum 30.07.2019.
* Die Daten des Datensatzes **KiWo** reichen vom 16.06.2012 bis zum 30.06.2019.
* Die Daten des Datensatzes **Wetter** reichen vom 01.01.2012 bis zum 01.08.2019.

### 2.4 Überprüfung der Datensätze auf fehlende Werte
```{r}
sum(is.na(Beispieldaten))
sum(is.na(KiWo))
sum(is.na(Wetter))
which(is.na(Wetter))
sum(is.na(Wetter$Datum))
sum(is.na(Wetter$Bewoelkung))
sum(is.na(Wetter$Temperatur))
sum(is.na(Wetter$Windgeschwindigkeit))
sum(is.na(Wetter$Wettercode))
```

* Der Datensatz **Beispieldaten** enthält keine fehlenden Werte.
* Der Datensatz **KiWo** enthält keine fehlenden Werte.
* Der Datensatz **Wetter** enthält 679 fehlende Werte, davon 10 in der Spalte "Bewoelkung", 669 in der Spalte "Wettercode".

### 2.5 Überprüfung der Datensätze auf Ausreißer

* Datensatz **Beispieldaten** 

```{r}
# Überprüfung der Variable Umsatz
boxplot(Beispieldaten$Umsatz)
hist(Beispieldaten$Umsatz)
density(Beispieldaten$Umsatz)
apropos("density")

# Visualisierung
Beispieldaten %>% 
  select(Umsatz) %>% 
  ggplot(aes(Umsatz)) +
  geom_density()
```

Das Attribut "Umsatz" enthält zahlreiche Ausreißer. (Umgang?)

* Datensatz **Wetter**
```{r}
boxplot(Wetter$Bewoelkung)
boxplot(Wetter$Temperatur)
boxplot(Wetter$Windgeschwindigkeit)
boxplot(Wetter$Wettercode)
```

Die Variable Windgeschwindigkeit enthält 7 Ausreißer.

....

### Deskriptive Statistik (?)

```{r}
# tapply
tapply(Beispieldaten$Umsatz, Beispieldaten[,2], sum)
tapply(Beispieldaten$Umsatz, Beispieldaten[,2], mean)

Beispieldaten %>%
  select(Warengruppe) %>%
  group_by(Warengruppe) %>%
  summarise(n = n())

Beispieldaten %>%
  group_by(Warengruppe) %>%
  summarise(min_dat=min(Datum), max_dat=max(Datum))
```

Für die Warengruppen 1, 2, 3 und 5 gibt es jeweils 2.174 Datensätze, für die Warengruppe 4 sind es 2.120 Datensätze. Auffällig ist, dass es für die Warengruppe 6 nur 348 Datensätze gibt. 

Die Datensätze für die ersten 5 Warengruppen erstrecken sich über denselben Zeitraum: 1.7.2013 bis 30.7.2019. Die erste Vermutung war, dass für die 6. Warengruppe nur ein eingeschränkter Zeitraum zur Verfügung steht. Dieser Verdacht wird widerlegt: Der Zeitraum der Daten für die 6. Warengruppe ist nur geringfügig kürzer und geht vom 24.10.2013 bis 28.12.2018.

FRAGE: Was verbirgt sich also hinter Warengruppe 6?

# 3 Datenaufbereitung

## 3.x Vereinigung der Datensätze

Bei der Untersuchung der Datumsvariablen der einzelnen Datensätze ergab sich, dass diese über unterschiedliche Zeiträume reichen:

* Die Daten des Datensatzes **Beispieldaten** reichen vom 01.07.2013 bis zum 30.07.2019.
* Die Daten des Datensatzes **KiWo** reichen vom 16.06.2012 bis zum 30.06.2019.
* Die Daten des Datensatzes **Wetter** reichen vom 01.01.2012 bis zum 01.08.2019.

Maßgeblich ist für uns an dieser Stelle der Datensatz "Beispieldaten", da wir abschließend an der Prognose der Umsätze je Warengruppe interessiert sind. Wenn für ein Datum keine Umsätze vorhanden sind, sind die Daten aus den anderen Daten unbrauchbar. Demzufolge wird ein `left_join` für die Vereinigung verwendet:

```{r}
df <- left_join(Beispieldaten, KiWo, by = "Datum")
df <- left_join(df, Wetter, by = "Datum")
head(df)
```

## 3.x Korrektur der Anzahl Nachkommastellen für einzelne Variablen

Die Variablen `Umsatz` und `Temperatur` enthalten jeweils vier Nachkommastellen, die als überflüssig und unsinnig erachtet werden. Die Anzahl der Nachkommstellen wird entsprechend korrigiert, wobei die Anzahl Nachkommastellen bei der Variable `Umsatz` auf 2 Nachkommastellen, die Variable `Temperatur` auf 1 Nachkommastelle gerundet wird:

```{r}
df <- df %>%
  mutate(Umsatz = round(Umsatz, 2)) %>% 
  mutate(Temperatur = round(Temperatur, 1))
head(df)
```


## 3.x Umgang mit fehlenden Werten

Der Datensatz **KiWo** enthält nur 72 Datensätze: für jedes Jahr wurde den Tagen, an denen die KiWo stattfindet, eine 1 zugeordnet. Diese Werte wurden Bei der Vereinigung der Datensätze entsprechend korrekt gemerged. Für alle anderen Daten, an denen keine KiWo ist, wurde bei der Vereinigung ein fehlender Wert (NA) automatisch erzeugt. Diese fehlenden Werte sind für die weitergehenden Analysen durch "0" zu ersetzen:

```{r}
df <- df %>%
  mutate(KielerWoche = replace_na(KielerWoche, 0))
head(df)
```

Da die Variable `Wettercode` vglw. viele fehlende Werte hat (669) und unklar ist, wie diese fehlenden Werte sinnvoll ersetzt werden können, wird diese Variable (vorläufig) ignoriert und eliminiert:

```{r}
df <- df[,1:7]
head(df)  
```

## 3.x Umgang mit Ausreißern

Zwei der 7 verbleibenden Variablen enthalten Ausreißer: `Umsatz` und `Windgeschwindigkeit`. Es werden vorerst keine Korrekturen an den Ausreißerdaten vorgenommen. Ggf. wird bei der Erstellung und Anwendung der Modelle hier eine Korrektur vorgenommen.

## 3.x Umgang mit Warengruppe 6

Die Anzahl der Datensätze je Warengruppe differiert teilweise stark, insbesondere Warengruppe 6 ist auffällig:

* Warengruppen 1, 2, 3 und 5: jeweils 2.174 Datensätze
* Warengruppe 4: 2.120 Datensätze
* Warengruppe 6: 348 Datensätze. 

Die Datensätze der Warengruppe 6 werden infolgedessen gelöscht:
```{r}
df <- df %>%
  filter(Warengruppe != 6)
```
Nach dem Löschen der Datensätze enthält der Datensatz nunmehr 10816 Zeilen.

## 3.x Wochentag und Jahr als neue Spalte ergänzt

Ein wesentlicher Einflussfaktor für die Umsatzprognose wird der Wochentag sein, wir fügen diesen als eigene Spalte hinzu: Sonntag (1), Montag (2), ... , Samstag (7). Und für die spätere Aufteilung der Daten in Training- und Testset wird das Jahr als weitere Spalte ergänzt.

```{r}
df <- df %>% mutate(Wochentag = wday(Datum))
df <- df %>% mutate(Jahr = year(Datum))
```

## Aufteilung des Datensatzes in Trainings- und Testset

Man kann stets ein Modell finden, welches die *vorhandenen* Daten (nahezu) exakt bechreibt. Das gleicht der Tatsache, dass man im Nachhinein (bei vorhandenen Daten) oftmals leicht eine Erklärung findet. Ob diese Erklärung sich auch bei unbekannten Daten bewahrheitet, muss jedoch geprüft werden. Daher werden die unterschiedlichen Modelle an einer Stichprobe *entwickelt* bzw. "trainiert" und an einer anderen Stichprobe *getested*. Die erste Stichprobe wird demzufolge als "trainingset" deklariert, die zweite als "testset". Die Güte der Modelle wird abschließend anhand des "testsets" überprüft.

Gemäß der vorhandenen Datenlage wird das Trainingset die Datensätze für die Jahre 2014 - 2017 umfassen (2013 wird aufgrund der nicht ganzjährig vorliegenden Daten ignoriert), das Testset die Daten aus dem Jahr 2018.

```{r}
trainingset <- df %>%
  filter(Jahr >= 2014 & Jahr <= 2017)

glimpse(trainingset)
head(trainingset)

testset <- df %>% 
  filter(Jahr == 2018)
```

Untersuche nun den Umsatz je Wochentag und/oder Warengruppe in den Trainingsdaten.

```{r}
df %>% group_by(Warengruppe) %>% summarise(Umsatz_sum = sum(Umsatz))
df %>% group_by(Wochentag) %>% summarise(Umsatz_sum = sum(Umsatz))
df %>% group_by(Warengruppe, Wochentag) %>% summarise(Umsatz_sum = sum(Umsatz))
```

Warengruppe 2 zeigt den höchsten Umsatz insgesamt, gefolgt von Warengruppe 5.
Die Wochentage Samstag (7) und Sonntag (1) sind mit leichtem Abstand die umsatzstärksten Tage, aggregiert über alle Warengruppen.

